<!doctype html>
<html>
   <head>
      <link rel="stylesheet" href="./css/overlay.css">
      <style>
         body{
            background-color:black;
         }
         #container{
            margin: auto;
            display:flex;
            width:1000px;
            height:600px;
            justify-content: center;
         }
         #overlay{
            /* display: none; */
         }
         .top_left{
            position:absolute;
            top:0;
            left:0;
            padding:20px;
            color:white;
            font-size: 25px;
            display:none;
         }
         .top_right{
            position:absolute;
            top:0;
            right:0;
            padding:20px;
            color:white;
            font-size: 25px;
            display:none;
         }
      </style>
   </head>
   <body>
      <div id="container">
         <canvas width = "1000" height = "600" id = "my_Canvas"></canvas>
         <div id="overlay">
            <div class="menu" id="menu_play" style="left:400px;">
               <button id="btn_play">PLAY</button>
            </div>
            <div class="menu" id="menu_decide_game">
               <button id="btn_new">NEW GAME</button>
               <button id="btn_connect">CONNECT TO GAME</button>
            </div>
            <div class="menu" id="menu_new_game">
               <label class="switch">
                  <input type="checkbox" id="checkbox_color">
                  <div class="in"><span>BLACK</span></div>
                  <div class="out"><span>WHITE</span></div>
               </label>
               <button id="btn_gen_room">CREATE ROOM</button>
            </div>
            <div class="menu" id="menu_join_game">
               <input type="text" place2holder="ROOM ID" id="inp_room_id">
               <button id="btn_join_room">JOIN</button>
            </div>
         </div>
         <div class="top_left" id="room_id">
            Room ID:
         </div>
         <div class="top_right" id="exit">
            <button id="btn_exit" class="btn_back">exit</button>
         </div>
         <div class="top_middle" id="error_alert"></div>
      </div>
      <script type="module">
         import * as vecMath from './js/math.mjs';
         import { loadGeometry, geo, geoParams } from "./js/geometry.mjs";
         import { mesh } from "./js/mesh.mjs";
         import { setup, clickMeshes, mouse } from "./js/gameengine.mjs";
         import { main_shader_program } from "./js/shaders.mjs";
         import { pieces, square, squares, spawnPieces, taken, game_input } from "./js/gameObjects.mjs";
         import { setupOverlay } from "./js/overlay.mjs";
         import { setupNetworking, movePiece } from './js/network.mjs';

         window.onload = () =>{
            setup(async () => {
               const loadCalls = [
                  loadGeometry("models/knight.obj", "knight"),
                  loadGeometry("models/rook.obj", "rook"),
                  loadGeometry("models/pawn.obj", "pawn"),
                  loadGeometry("models/king.obj", "king"),
                  loadGeometry("models/bishop.obj", "bishop"),
                  loadGeometry("models/queen.obj", "queen"),
                  main_shader_program.loadImageIntoSampler("./chesstex.jpg", "uChessTex")
               ];

               return Promise.all(loadCalls).then(()=>{
                  for(var i=0; i<8; i++){
                     for(var j=0; j<8; j++){
                        new square(i,j);
                     }
                  }

                  // generate board edges 
                  const dim = 4;
                  const diff = dim + .05;
                  const offset = -1.2;
                  const planeParams = new geoParams();

                  let coords = [
                     [-dim,-1,-dim, -diff,offset,-diff, dim,-1,-dim, diff,offset,-diff],
                     [dim,-1,-dim, diff,offset,-diff, dim,-1,dim, diff,offset,diff],
                     [dim,-1,dim, diff,offset,diff, -dim,-1,dim, -diff,offset,diff],
                     [-dim,-1,dim, -diff,offset,diff, -dim,-1,-dim, -diff,offset,-diff]
                  ];

                  for(let i=0; i<4; i++){
                     let j = i*4;
                     planeParams.vertices.push(...coords[i]);
                     planeParams.normals.push(0,1,0, 0,1,0, 0,1,0, 0,1,0);
                     planeParams.indices.push(j,j+1,j+2, j+1,j+2,j+3);
                     planeParams.texcoors.push(0,0, 0,0, 0,0, 0,0);
                  }

                  const planeGeo = new geo("board_back", planeParams);
                  const planeMesh = new mesh("board_back");
                  planeMesh.setTexIndex(2);

                  spawnPieces();

                  setupNetworking();

                  setupOverlay();
               });
            }, () => {
               pieces.forEach(piece=>{piece.update();});
               taken.forEach(piece=>{piece.update();});
            });
         };

         let canvas = document.getElementById("my_Canvas");
         let availableMoves = [];

         let colorMoves = ()=>{
            availableMoves.forEach(mov=>{
               squares[mov.pos[0]][mov.pos[1]].mesh.setTexIndex(3);
               if(typeof mov.attacking !== 'undefined'){
                  mov.attacking.mesh.setTexIndex(3);
               }
            })
         };

         let selected;
         
         canvas.addEventListener('mouseup', (event)=>{
            if(!game_input){return;}
            if(!mouse.dragging){
               const clickedMesh = clickMeshes(event);
               if(clickedMesh){
                  if(!selected){
                     if(clickedMesh.ob.type){
                        availableMoves = clickedMesh.ob.showMoves();
                        selected = clickedMesh.ob;
                     }
                  }else{
                     if(clickedMesh.ob == selected){
                        selected = 0;
                        availableMoves = [];
                     }else if(clickedMesh.texindex == 4){
                        pieces.forEach(p=>{p.enpassant = false;})

                        const performed_move = availableMoves.find(move => 
                              vecMath.same2D(...clickedMesh.ob.pos, ...move.pos)
                           || move.attacking == clickedMesh.ob
                           );
                        movePiece(performed_move.piece.pos, performed_move.pos);

                        selected = 0;
                        availableMoves = [];
                     }else if(clickedMesh.ob.type){
                        availableMoves = [];
                        availableMoves = clickedMesh.ob.showMoves();
                        selected = clickedMesh.ob;
                     }
                  }
               }

               pieces.forEach(piece=>piece.resetTexIndex());
               squares.forEach(row=>
                  row.forEach(square=>
                     square.mesh.setTexIndex(0)
                  )
               );

               colorMoves();
            }
         });

         let mouseOver;
         canvas.addEventListener("mousemove", (event) =>{
            if(!game_input){return;}
            if(!selected){return;}
            if(mouse.state == mouse.states.UP){
               const meshUnderMouse = clickMeshes(event);
               if(!meshUnderMouse || mouseOver == meshUnderMouse){return;}

               mouseOver = meshUnderMouse;

               const move = availableMoves.find(mov => 
                     vecMath.same2D(...meshUnderMouse.ob.pos, ...mov.pos)
                  || mov.attacking == meshUnderMouse.ob
               );
               
               colorMoves();
               
               if(move){
                  squares[move.pos[0]][move.pos[1]].mesh.setTexIndex(4);
                  if(move.attacking){
                     move.attacking.mesh.setTexIndex(4);
                  }
               }
            }
         });
      </script>
   </body>
</html>