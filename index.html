<!doctype html>
<html>
   <head>
      <link rel='stylesheet' href='./css/overlay.css'>
      <style>
         body{
            background-color:black;
         }
         #container{
            margin: auto;
            display:flex;
            width:1000px;
            height:600px;
            justify-content: center;
         }
         #overlay{
            /* display: none; */
         }
         .top_left{
            position:absolute;
            top:0;
            left:0;
            padding:20px;
            color:white;
            font-size: 25px;
            display:none;
         }
         .top_right{
            position:absolute;
            top:0;
            right:0;
            padding:20px;
            color:white;
            font-size: 25px;
            display:none;
         }
         .bottom_center{
            text-align: center;
            font-size: 25px;
            color: rgb(207, 207, 207);
            position:absolute;
            bottom: 0px;
            padding:10px 0 20px 0;
            width:99%;
            background-color: black;
         }
         a{
            color:blueviolet;
         }
      </style>
   </head>
   <body>
      <div id='container'>
         <canvas width = '800' height = '600' id = 'my_Canvas'></canvas>
         <div id='overlay'>
            <div class='menu' id='menu_play' style='left:400px;'>
               <button id='btn_play'>PLAY</button>
            </div>
            <div class='menu' id='menu_decide_game'>
               <button id='btn_new'>NEW GAME</button>
               <button id='btn_connect'>CONNECT TO GAME</button>
               <button id='btn_demo'>DEMO</button>
            </div>
            <div class='menu' id='menu_new_game'>
               <label class='switch'>
                  <input type='checkbox' id='checkbox_color'>
                  <div class='in'><span>BLACK</span></div>
                  <div class='out'><span>WHITE</span></div>
               </label>
               <button id='btn_gen_room'>CREATE ROOM</button>
            </div>
            <div class='menu' id='menu_join_game'>
               <input type='text' place2holder='ROOM ID' id='inp_room_id'>
               <button id='btn_join_room'>JOIN</button>
            </div>
         </div>
         <div class='top_left' id='room_id'>
            Room ID:
         </div>
         <div class='top_right' id='exit'>
            <button id='btn_exit' class='btn_back'>exit</button>
         </div>
         <div class='top_middle' id='error_alert'></div>
      </div>
      <div class='bottom_center'>
         Michael Tchistopolskii, 2022 - <a href='https://github.com/realJavabot/webgl_chess'>https://github.com/realJavabot/webgl_chess</a>
      </div>
      <script type='module'>
         import * as vecMath from '/webgl_chess/js/math.mjs';
         import { loadGeometry, geo, geoParams } from '/webgl_chess/js/geometry.mjs';
         import { mesh } from '/webgl_chess/js/mesh.mjs';
         import { setup, clickMeshes, mouse, singleplayer } from '/webgl_chess/js/gameengine.mjs';
         import { main_shader_program } from '/webgl_chess/js/shaders.mjs';
         import { pieces, square, squares, spawnPieces, taken, game_input, resetBoard } from '/webgl_chess/js/gameObjects.mjs';
         import { setupOverlay } from '/webgl_chess/js/overlay.mjs';
         import { setupNetworking, movePiece } from '/webgl_chess/js/network.mjs';

         window.onload = () =>{
            setup(async () => {
               const loadCalls = [
                  loadGeometry('models/knight.obj', 'knight'),
                  loadGeometry('models/rook.obj', 'rook'),
                  loadGeometry('models/pawn.obj', 'pawn'),
                  loadGeometry('models/king.obj', 'king'),
                  loadGeometry('models/bishop.obj', 'bishop'),
                  loadGeometry('models/queen.obj', 'queen'),
                  main_shader_program.loadImageIntoSampler('/webgl_chess/resources/chesstex.jpg', 'uChessTex')
               ];

               return Promise.all(loadCalls).then(()=>{
                  resetBoard();

                  setupNetworking();

                  setupOverlay();
               });
            }, () => {
               pieces.forEach(piece=>{piece.update();});
               taken.forEach(piece=>{piece.update();});
            });
         };

         let canvas = document.getElementById('my_Canvas');
         let availableMoves = [];

         let colorMoves = ()=>{
            availableMoves.forEach(mov=>{
               squares[mov.pos[0]][mov.pos[1]].mesh.setTexIndex(3);
               if(typeof mov.attacking !== 'undefined'){
                  mov.attacking.mesh.setTexIndex(3);
               }
            })
         };

         let selected;
         
         canvas.addEventListener('mouseup', (event)=>{
            if(!game_input){return;}
            if(!mouse.dragging){
               const clickedMesh = clickMeshes(event);
               if(clickedMesh){
                  if(!selected){
                     if(clickedMesh.ob.type){
                        availableMoves = clickedMesh.ob.showMoves();
                        selected = clickedMesh.ob;
                     }
                  }else{
                     if(clickedMesh.ob == selected){
                        selected = 0;
                        availableMoves = [];
                     }else if(clickedMesh.texindex == 4){
                        pieces.forEach(p=>{p.enpassant = false;})

                        const performed_move = availableMoves.find(move => 
                              vecMath.same2D(...clickedMesh.ob.pos, ...move.pos)
                           || move.attacking == clickedMesh.ob
                           );
                        if(singleplayer){
                           performed_move.perform();
                        }else{
                           movePiece(performed_move.piece.pos, performed_move.pos);
                        }

                        selected = 0;
                        availableMoves = [];
                     }else if(clickedMesh.ob.type){
                        availableMoves = [];
                        availableMoves = clickedMesh.ob.showMoves();
                        selected = clickedMesh.ob;
                     }
                  }
               }

               pieces.forEach(piece=>piece.resetTexIndex());
               squares.forEach(row=>
                  row.forEach(square=>
                     square.mesh.setTexIndex(0)
                  )
               );

               colorMoves();
            }
         });

         let mouseOver;
         canvas.addEventListener('mousemove', (event) =>{
            if(!game_input){return;}
            if(!selected){return;}
            if(mouse.state == mouse.states.UP){
               const meshUnderMouse = clickMeshes(event);
               if(!meshUnderMouse || mouseOver == meshUnderMouse){return;}

               mouseOver = meshUnderMouse;

               const move = availableMoves.find(mov => 
                     vecMath.same2D(...meshUnderMouse.ob.pos, ...mov.pos)
                  || mov.attacking == meshUnderMouse.ob
               );
               
               colorMoves();
               
               if(move){
                  squares[move.pos[0]][move.pos[1]].mesh.setTexIndex(4);
                  if(move.attacking){
                     move.attacking.mesh.setTexIndex(4);
                  }
               }
            }
         });
      </script>
   </body>
</html>