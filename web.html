<!doctype html>
<html>
   <head>
      <style>
         body{
            background-color:rgba(127.5, 127.5, 127.5, 0.9);
         }
         canvas{
            margin: auto;
            display:block;
         }
      </style>
   </head>
   <body>
      <canvas width = "800" height = "500" id = "my_Canvas"></canvas>
      <script type="module">
         import * as vecMath from './math.mjs';
         import { loadGeometry, geo } from "./geometry.mjs";
         import { mesh, meshes, generateMeshBuffers } from "./mesh.mjs";
         import { setup, update, clickMeshes, mouse } from "./gameengine.mjs";
         import { pieces, square, squares, spawnPieces, taken } from "./gameObjects.mjs";
         import { loadTex } from "./texture.mjs";

         window.onload = () =>{
            setup(() => {
               const loadCalls = [
                  loadGeometry("./models/knight.obj", "knight"),
                  loadGeometry("./models/rook.obj", "rook"),
                  loadGeometry("./models/pawn.obj", "pawn"),
                  loadGeometry("./models/king.obj", "king"),
                  loadGeometry("./models/bishop.obj", "bishop"),
                  loadGeometry("./models/queen.obj", "queen"),
                  loadTex("./chesstex.jpg", "uChessTex")
               ];

               Promise.all(loadCalls).then(()=>{
                  for(var i=0; i<8; i++){
                     for(var j=0; j<8; j++){
                        new square(i,j);
                     }
                  }

                  const dim = 4;
                  const diff = dim + .05;
                  const offset = -1.2;
                  const planeGeo = new geo("board_back");
                  const planeMesh = new mesh("board_back");

                  planeGeo.vertices.push(-diff,offset,-diff, diff,offset,-diff, diff,offset,diff, -diff,offset,diff);
                  planeGeo.normals.push(0,1,0, 0,1,0, 0,1,0, 0,1,0);
                  planeGeo.indices.push(0,1,2, 0,2,3);
                  planeGeo.texcoors.push(0,0, 0,0, 0,0, 0,0);
                  let coords = [
                     [-dim,-1,-dim, -diff,offset,-diff, dim,-1,-dim, diff,offset,-diff],
                     [dim,-1,-dim, diff,offset,-diff, dim,-1,dim, diff,offset,diff],
                     [dim,-1,dim, diff,offset,diff, -dim,-1,dim, -diff,offset,diff],
                     [-dim,-1,dim, -diff,offset,diff, -dim,-1,-dim, -diff,offset,-diff]
                  ];
                  for(let i=0; i<4; i++){
                     let j = (i+1)*4;
                     planeGeo.vertices.push(...coords[i]);
                     planeGeo.normals.push(0,1,0, 0,1,0, 0,1,0, 0,1,0);
                     planeGeo.indices.push(j,j+1,j+2, j+1,j+2,j+3);
                     planeGeo.texcoors.push(0,0, 0,0, 0,0, 0,0);
                  }
                  planeGeo.length = planeGeo.vertices.length;

                  planeMesh.setTexIndex(2);

                  spawnPieces();
               });
            }, () => {
               pieces.forEach(piece=>{piece.update();});
               taken.forEach(piece=>{piece.update();});
            });
         };

         let canvas = document.getElementById("my_Canvas");
         let availableMoves = [];

         let colorMoves = ()=>{
            availableMoves.forEach(mov=>{
               if(mov.pos[0] >= 0 && mov.pos[1] >= 0){
                  squares[mov.pos[0]][mov.pos[1]].mesh.setTexIndex(3);
               }
               pieces.forEach(piece=>{
                  if(piece.pos[0] == mov.pos[0] && piece.pos[1] == mov.pos[1]){
                     piece.mesh.setTexIndex(3);
                  }
               });
            })
         };

         let selected;
         
         canvas.addEventListener('mouseup', (event)=>{
            if(!mouse.dragging){
               const numMesh = clickMeshes(event);

               if(numMesh<meshes.length && numMesh>=0 && meshes[numMesh].ob){
                  const clickedMesh = meshes[numMesh];
                  if(!selected){
                     if(clickedMesh.ob.type){
                        availableMoves = clickedMesh.ob.showMoves();
                        selected = clickedMesh.ob;
                     }
                  }else{
                     if(clickedMesh.ob == selected){
                        selected = 0;
                        availableMoves = [];
                     }else if(clickedMesh.texindex == 4){
                        selected.moveTo(...clickedMesh.ob.pos);
                        selected = 0;
                        availableMoves = [];
                     }else if(clickedMesh.ob.type){
                        availableMoves = [];
                        availableMoves = clickedMesh.ob.showMoves();
                        selected = clickedMesh.ob;
                     }
                  }
               }

               pieces.forEach(piece=>piece.resetTexIndex());
               squares.forEach(row=>
                  row.forEach(square=>
                     square.mesh.setTexIndex(0)
                  )
               );

               colorMoves();
            }
         });

         let mouseOver;
         canvas.addEventListener("mousemove", (event) =>{
            if(!selected){return;}
            if(mouse.state == mouse.states.UP){
               const meshUnderMouse = meshes[clickMeshes(event)];
               if(!meshUnderMouse || mouseOver == meshUnderMouse){return;}

               mouseOver = meshUnderMouse;

               const moveSquare = availableMoves.find(mov => vecMath.same2D(...mouseOver.ob.pos, ...mov.pos));
               
               colorMoves();
               
               if(moveSquare){
                  squares[moveSquare.pos[0]][moveSquare.pos[1]].mesh.setTexIndex(4);
                  const hoverPiece = pieces.find(p => vecMath.same2D(...p.pos, ...moveSquare.pos));
                  if(hoverPiece){
                     hoverPiece.mesh.setTexIndex(4);
                  }
               }
            }
         });
      </script>
   </body>
</html>